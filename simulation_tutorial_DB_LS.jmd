# # Simulation Tutorial
# ### Lisa DeBruine, Daniel Backhaus
# ### 2020-02-17
# ## Setup 
# 
# ### Julia
# 
# Load the packages we'll be using in Julia. In pkg run the following to get the versions we're using:
# 
# * `add MixedModels#master`
# * `add https://github.com/RePsychLing/MixedModelsSim.jl#master`


using MixedModels        # run mixed models DANIEL
using MixedModelsSim     # simulation functions for mixed models
using RCall              # call R functions from inside Julia
using DataFrames, Tables # work with data tables
using StableRNGs         # random number generator
using CSV                # write CSV files
using Markdown
using LinearAlgebra      # not used yet, for specifing θ



R"""
require(tidyverse, quietly = TRUE)   # for data wrangling and visualisation
""";


# ### Define Custom functions
# 
# It's useful to be able to weave your file quickly while you're debugging, 
# so set the number of simulations to a relatively low number while you're 
# setting up your script and change it to a larger number when everything
# is debugged.



nsims = 1000 # set to a low number for test, high for production


# ## Existing Data
# 
# Load existing data. Set the contrasts and run model.

# load data
kb07 = MixedModels.dataset("kb07");

# set contrasts
contrasts = Dict(:spkr => HelmertCoding(), 
                 :prec => HelmertCoding(), 
                 :load => HelmertCoding());

# define formula
kb07_f = @formula( rt_trunc ~ 1 + spkr+prec+load + (1|subj) + (1+prec|item) );

# fit model
kb07_m = fit(MixedModel, kb07_f, kb07, contrasts=contrasts);
print(kb07_m)


# ### Simulate data with same parameters
# 
# Use the `parameparametricbootstrap()` function to run `nsims` iterations of data sampled using the parameters from `kb07_m`. 
# Set up a random seed to make the simulation reproducible. You can use your favourite number.
# 
# To use multithreading, you need to set the number of cores you want to use. In Visual Studio Code, open the settings (gear icon in the lower left corner or cmd-,) and search for "thread". Set `julia.NumThreads` to the number of cores you want to use (at least 1 less than your total number).


# set random seed for reproducibility
rng = StableRNG(42);

# run nsims iterations
kb07_sim = parametricbootstrap(rng, nsims, kb07_m, use_threads = false);


# **Try**: Run the code above with and without `use_threads = true`.
# 
# Convert p-values to dataframe.


kb07_sim_df = DataFrame(kb07_sim.coefpvalues);
CSV.write("kb07_sim.csv", kb07_sim_df);


print(first(kb07_sim_df, 8))

### Power calculation

# The function `power_table()` from `MixedModelsSim` takes the output of `parametricbootstrap()` and calculates the proportion of simulations where the p-value is less than alpha for each coefficient. You can set the `alpha` argument to change the default value of 0.05 (justify your alpha ;).

ptbl = power_table(kb07_sim)

# For nicely displaying it, we can use pretty_table:

pretty_table(ptbl)







# toDo color and facet didnt work
```{julia;label=pleasecorrect}
R"""
d <- $kb07_sim_df

ggplot(d, aes(x=!!as.name("\u03b2"),  color= coefname))+
  geom_density(show.legend = FALSE)+
  facet_wrap(~coefname, scales = "free")

"""

# or as function 
# #### Define: ggplot_betas
# 
# This function plots the beta values returned from `parametricbootstrap` using ggplot in R.
# If you set a figname, it will save the plot to the specified file.


function ggplot_betas(sim, figname = 0, width = 7, height = 5) 

    df = DataFrame(sim.coefpvalues)

    R"""
    
    p <- $df %>%
     rename(beta = !!as.name("\u03b2"))
     ggplot(aes(x=!!as.name("\u03b2"),  color=coefname ))+
      geom_density(show.legend = FALSE)+
      facet_wrap(~coefname, scales = "free")

        if (is.character($figname)) {
            ggsave($figname, p, width = $width, height = $height)
        }

        p
    """
end



# Plot betas in ggplot. In the code editor or Jupyter notebooks, you can omit the file name to just display the figure in an external window.



# just display the image
# ggplot_betas(kb07_sim) 
# save the image to a file and display (display doesn't work in weave)
ggplot_betas(kb07_sim, "kb07_betas.png")



# In documents you want to weave, save the image to a file and use markdown to display the file. Add a semicolon to the end of the function to suppress creating the images in new windows during weaving.

# ![](fig/kb07_betas.png)
```














### Change parameters without touching the existing data 

# Let's say we want to check our power to detect effects of spkr, prec, and load 
# that are half the size of our pilot data. We can set a new vector of beta values 
# with the `β` argument to `parametricbootstrap()`.


newβ = kb07_m.β
newβ[2:4] = kb07_m.β[2:4]/2

kb07_sim_half = parametricbootstrap(rng, nsims, kb07_m, β = newβ, use_threads = false);

power_table(kb07_sim_half)


# Simulating Data from Scratch


# If we simulate data from scratch, next to subject and item number, we can manipulate the arguments 'β', 'σ' and 'θ'.
# Lets have a closer look at them and we will see where the corresponding values in the model output are.

# β are our effect sizes. If we look again on our LMM summary from the kb07-dataset 'kb07_m'
kb07_m
# we see our 4 β under fixed-effects parameters in the Coef.-column. 
kb07_m.β

# σ is the residual-standard deviation listed under the variance components. 
kb07_m.σ

# θ is a more complex parameter. In a less complex model, with only intercepts for our random effects, 
# or if we supress the correlations in the formula with zerocorr() then θ describes the relationship between 
# the random effects standard deviation and the standard deviation of the residual term.

# In our kb07_m example:
# The residual standard deviation is 680.032 
# The standard deviation of our first variance component 'item - (Intercept)' is 364.713.
# Thus our first θ is the relationship: variance component devided by residual standard deviation
# 364.713 /  680.032 =  0.53631

kb07_m.θ

# We also can calculate the θ for variance component 'subj - (Intercept)'. The standard deviation is 298.026. is 364.713.the random intercept for subjects. 
# Thus the retated θ is the relationship: variance component devided by residual standard deviation
# 298.026 /  680.032 =  0.438252

kb07_m.θ

# We can not calculate the θ for variance component 'item - prec: maintain' yet, because it includes the correlation of 
# "item - prec: maintain" and "item - (Intercept)". The θ vector is the flattened version of the variance-covariance matrix - 
# a lowertrinangular matrix.
# The on-diagonal elements are just the standard deviations (the σ's), If all off-diagonal elements are zero, we can use our
# calculation above. The off-diagonal elements are covariances and correspond to the correlations (the ρ's). If they are unequal to zero, as
# it is in our kb07-dataset, we cannot recreate the variance-covariance matrix having the Model output.
# We just take it from the Model we already fitted

kb07_m.θ


```{julia;label=needexplainationhere}

# please help, maybe it is possible the achive the theta?


vc = VarCorr(kb07_m)
vc.σρ
kb07_m.λ
kb07_m.λ[1]
kb07_m.λ[2]


λitem = LowerTriangular(diagm([1.3, 0.35, 0.75]))
λsubj = LowerTriangular(diagm([1.5, 0.5, 0.75]))

isapprox(kb07_m.θ,  [flatlowertri(kb07_m.λ[1]); flatlowertri(kb07_m.λ[2])])

[flatlowertri(λitem); flatlowertri(λsubj)]


# make a lower triangular matricis
re_item = create_re(0.5363168233715857,0)
re_item[4]=0.37133693708531357

re_subj = create_re(0.4382528181348316)
# make the compact form out of it = is equal to θ 
vcat( flatlowertri(re_item), flatlowertri(re_subj) )


```


# Having this knowledge about the parameter we can 
# Simulating Data from Scratch


## simdat_crossed

The `simdat_crossed()` function from `MixedModelsSim` lets you set up a data frame with a specified experimental design. 
For now, it only makes fully balanced crossed designs!, but you can generate an unbalanced design by simulating data for the largest cell and deleting extra rows. 

Firstly we will set an easy design where `subj_n` subjects per `age` group (O or Y) respond to `item_n` items in each of two `condition`s (A or B).

Your factors need to be specified separately for between-subject, between-item, and within-subject/item factors using `Dict` with the name of each factor as the keys and vectors with the names of the levels as values.

# put between-subject factors in a Dict
subj_btwn = Dict("age" => ["O", "Y"])

# there are no between-item factors in this design so you can omit it or set it to nothing
item_btwn = nothing

# put within-subject/item factors in a Dict
both_win = Dict("condition" => ["A", "B"])



# simulate data
dat = simdat_crossed(10, 30, 
                     subj_btwn = subj_btwn, 
                     item_btwn = item_btwn, 
                     both_win = both_win);

# write nothing if you havent one of the factor types 

first(DataFrame(dat),8)

#The values we see in the column 'dv' is just random noise.

## Fit a model

Now you need to fit a model to your simulated data. Because the `dv` is just random noise from N(0,1), there will be basically no subject or item random variance, residual variance will be near 1.0, and the estimates for all effects should be small. Don't worry, we'll specify fixed and random effects directly in `parametricbootstrap`. 


# set contrasts
contrasts = Dict(:age => HelmertCoding(), 
                 :condition => HelmertCoding());

f1 = @formula dv ~ 1 + age * condition + (1|item) + (1|subj);
m1 = fit(MixedModel, f1, dat, contrasts=contrasts)


## Simulate

Set a seed for reproducibility and specify β, σ, and θ.


rng = StableRNG(42);

new_beta = [0., 0.25, 0.25, 0.]
new_sigma = 2.0
new_theta = [1.0, 1.0]

sim1 = parametricbootstrap(rng, nsims, m1, 
                        β = new_beta, 
                        σ = new_sigma, 
                        θ = new_theta,
                        use_threads = false);


power_table(sim1)














## lets recreate the kb07 from scratch

rng = StableRNG(42);


subj_n = 56
item_n = 32

nsims = 1000


subj_btwn = nothing
item_btwn = nothing
both_win = Dict("spkr" => ["old", "new"],
                "prec" => ["maintain", "break"],
                "load" => ["yes", "no"])


fake_kb07 = simdat_crossed(subj_n, item_n, 
                     subj_btwn = subj_btwn, 
                     item_btwn = item_btwn, 
                     both_win = both_win);

fake_kb07_df = DataFrame(fake_kb07)

fake_kb07_df

# change sorting for  later selection

fake_kb07_df = unstack(fake_kb07_df, :item, :dv)   # makes wide format  
fake_kb07_df = stack(fake_kb07_df, 5:36, variable_name = :item)  # makes long format
rename!(fake_kb07_df, :value => :dv)

fake_kb07_df = unstack(fake_kb07_df, :subj, :dv)
fake_kb07_df = stack(fake_kb07_df, 5:60, variable_name = :subj)


rename!(fake_kb07_df, :value => :rt_trunc)


CSV.write("fake_kb07_df.csv", fake_kb07_df);

# Our original design is not fully crossed. Every subject saw an image only once, thus in one of eight possible 
# conditions. To simulate that we only keep 1 of every eight lines.

## is this a mistake and it is possible with a better use of simdat_crossed?


idx = rand(rng, 1:8 , 1792)

A = repeat([8], inner=1791)
A = append!( [0], A )
A = cumsum(A)
idx = idx+A

fake_kb07_df= fake_kb07_df[idx, :]


# set contrasts
contrasts = Dict(:spkr => HelmertCoding(), 
                 :prec => HelmertCoding(), 
                 :load => HelmertCoding());

# define formula, same as above
kb07_f = @formula( rt_trunc ~ 1 + spkr+prec+load + (1|subj) + (1+prec|item) );


# fit model
fake_kb07_m = fit(MixedModel, kb07_f, fake_kb07_df, contrasts=contrasts);
print(fake_kb07_m)


# change parameter to values we know from the model of the existing data

new_beta = [2181.85, 67.879, -333.791, 78.5904]
new_sigma = 680.032
new_theta = [0.5363168233715857,
           -0.25981993107379,
            0.2653016002105174,
            0.4382528181348316]
new_theta = kb07_m.θ



fake_kb07_sim = parametricbootstrap(rng, nsims, fake_kb07_m, 
                        β = new_beta, 
                        σ = new_sigma, 
                        θ = new_theta,
                        use_threads = false);


power_table(fake_kb07_sim)

# compare to powertable from the existing data
power_table(kb07_sim)


# we have successfully recreate the powersimulation of existing data from sratch
# the adventages are, that we now can interate over different numbers of subjects and items.

